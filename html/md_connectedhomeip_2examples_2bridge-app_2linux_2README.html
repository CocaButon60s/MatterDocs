<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MatterDocs: Matter Linux Bridge Example</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MatterDocs
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 構築: Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','検索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">読み取り中…</div>
<div class="SRStatus" id="Searching">検索中…</div>
<div class="SRStatus" id="NoMatches">一致する文字列を見つけられません</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Matter Linux Bridge Example</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md0"></a> An example demonstrating a simple lighting bridge and the use of dynamic endpoints. The document will describe the theory of operation and how to build and run Matter Linux Bridge Example on Raspberry Pi. This doc is tested on <b>Ubuntu for Raspberry Pi Server 20.04 LTS (aarch64)</b> and <b>Ubuntu for Raspberry Pi Desktop 20.10 (aarch64)</b></p>
<hr  />
<ul>
<li>Matter Linux Bridge Example<ul>
<li>Theory of Operation<ul>
<li>Dynamic Endpoints</li>
<li>Limitations</li>
<li>Bridge Implementation Example</li>
</ul>
</li>
<li>Building</li>
<li>Running the Complete Example on Raspberry Pi 4</li>
</ul>
</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md1"></a>
Theory of Operation</h1>
<h2><a class="anchor" id="autotoc_md2"></a>
Dynamic Endpoints</h2>
<p>The Bridge Example makes use of Dynamic Endpoints. Current SDK support is limited for dynamic endpoints, since endpoints are typically defined (along with the clusters and attributes they contain) in a .zap file which then generates code and static structures to define the endpoints.</p>
<p>To support endpoints that are not statically defined, the ZCL attribute storage mechanisms will hold additional endpoint information for <code>NUM_DYNAMIC_ENDPOINTS</code> additional endpoints. These additional endpoint structures must be defined by the application and can change at runtime.</p>
<p>To facilitate the creation of these endpoint structures, several macros are defined:</p>
<p><code><a class="el" href="attribute-storage_8h.html#a8a4ce7623749fcc857cda3596cae2432">DECLARE_DYNAMIC_ATTRIBUTE_LIST_BEGIN(attrListName)</a></code> <code><a class="el" href="attribute-storage_8h.html#aad226982447131971ea44dd423f62904">DECLARE_DYNAMIC_ATTRIBUTE(attId, attType, attSizeBytes, attrMask)</a></code> <code><a class="el" href="attribute-storage_8h.html#a239257f5448ae3f3362362be13ba6396">DECLARE_DYNAMIC_ATTRIBUTE_LIST_END(clusterRevision)</a></code></p>
<ul>
<li>These three macros are used to declare a list of attributes for use within a cluster. The declaration must begin with the <code>DECLARE_DYNAMIC_ATTRIBUTE_LIST_BEGIN</code> macro which will define the name of the allocated attribute structure. Each attribute is then added by the <code>DECLARE_DYNAMIC_ATTRIBUTE</code> macro. Finally, <code>DECLARE_DYNAMIC_ATTRIBUTE_LIST_END</code> macro should be used to close the definition.</li>
<li>All attributes defined with these macros will be configured as <code>MATTER_ATTRIBUTE_FLAG_EXTERNAL_STORAGE</code> in the ZCL database and therefore will rely on the application to maintain storage for the attribute. Consequently, reads or writes to these attributes must be handled within the application by the <code>emberAfExternalAttributeWriteCallback</code> and <code>emberAfExternalAttributeReadCallback</code> functions. See the bridge application's <code><a class="el" href="main_8cpp.html">main.cpp</a></code> for an example of this implementation.</li>
</ul>
<p><code><a class="el" href="attribute-storage_8h.html#ad31f840f1b317d4d2ddb1baf8e47bb4c">DECLARE_DYNAMIC_CLUSTER_LIST_BEGIN(clusterListName)</a></code> <code><a class="el" href="attribute-storage_8h.html#aa04f1f25abbea4750ac4db17c8849640">DECLARE_DYNAMIC_CLUSTER(clusterId, clusterAttrs, role, incomingCommands, outgoingCommands)</a></code> <code>DECLARE_DYNAMIC_CLUSTER_LIST_END</code></p>
<ul>
<li>These three macros are used to declare a list of clusters for use within a endpoint. The declaration must begin with the <code>DECLARE_DYNAMIC_CLUSTER_LIST_BEGIN</code> macro which will define the name of the allocated cluster structure. Each cluster is then added by the <code>DECLARE_DYNAMIC_CLUSTER</code> macro referencing attribute list previously defined by the <code>DECLARE_DYNAMIC_ATTRIBUTE...</code> macros and the lists of incoming/outgoing commands terminated by kInvalidCommandId (or nullptr if there aren't any commands in the list). Finally, <code>DECLARE_DYNAMIC_CLUSTER_LIST_END</code> macro should be used to close the definition.</li>
</ul>
<p><code><a class="el" href="attribute-storage_8h.html#af759ec72726f132f5ae30046269095da">DECLARE_DYNAMIC_ENDPOINT(endpointName, clusterList)</a></code></p>
<ul>
<li>This macro is used to declare an endpoint and its associated cluster list, which must be previously defined by the <code>DECLARE_DYNAMIC_CLUSTER...</code> macros.</li>
</ul>
<h2><a class="anchor" id="autotoc_md3"></a>
Limitations</h2>
<p>Because code generation is dependent upon the clusters and attributes defined in the .zap file (for static endpoint generation), it is necessary to include a defined endpoint within the .zap that contains <em>all</em> the clusters that may be used on dynamic endpoints. On the bridge example, this is done on endpoint 1, which is used as a 'dummy' endpoint that will be disabled at runtime. Endpoint 0 is also defined in the .zap and contains the bridge basic and configuration clusters as well as the root descriptor cluster.</p>
<h2><a class="anchor" id="autotoc_md4"></a>
Bridge Implementation Example</h2>
<p>The example demonstrates the use of dynamic endpoints and the concept of adding and removing endpoints at runtime. First, the example declares a <code>bridgedLightEndpoint</code> data structure for a Light endpoint with <code>OnOff</code>, <code>Descriptor</code>, <code>BridgedDeviceBasicInformation</code>, and <code>FixedLabel</code> clusters.</p>
<p>Using this declared endpoint structure, three endpoints for three bridged lights are dynamically added at endpoint ID's <code>2</code>, <code>3</code>, and <code>4</code>, representing <code>Light 1</code>, <code>Light 2</code>, and <code>Light 3</code> respectively.</p>
<p>Then, endpoint <code>3</code> is removed, simulating the deletion of <code>Light 2</code>.</p>
<p>A fourth light, <code>Light 4</code>, is then added occupying endpoint ID <code>5</code>.</p>
<p>Finally, <code>Light 2</code> is re-added, and will occupy endpoint ID <code>6</code>.</p>
<p>All endpoints populate the <code>Bridged <a class="el" href="classDevice.html">Device</a> Basic Information</code> and <code>Fixed Label</code> clusters. In the <code>Bridged <a class="el" href="classDevice.html">Device</a> Basic Information</code> cluster, the <code>reachable</code> attribute is simulated. In the <code>Fixed Label</code> cluster, the <code>LabelList</code> attribute is simulated with the value/label pair <code>"room"</code>/<code>[light name]</code>.</p>
<h1><a class="anchor" id="autotoc_md5"></a>
Building</h1>
<ul>
<li><p class="startli">Install tool chain</p>
<p class="startli"><code>sh sudo apt-get install git gcc g++ python pkg-config libssl-dev libdbus-1-dev libglib2.0-dev ninja-build python3-venv python3-dev unzip </code></p>
</li>
<li><p class="startli">Build the example application:</p>
<p class="startli"><code>sh cd ~/connectedhomeip/examples/bridge-app/linux git submodule update --init source third_party/connectedhomeip/scripts/activate.sh gn gen out/debug ninja -C out/debug </code></p>
</li>
<li><p class="startli">To delete generated executable, libraries and object files use:</p>
<p class="startli"><code>sh cd ~/connectedhomeip/examples/bridge-app/linux rm -rf out/ </code></p>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md6"></a>
Running the Complete Example on Raspberry Pi 4</h1>
<ul>
<li>Prerequisites<ol type="1">
<li>A Raspberry Pi 4 board</li>
<li>A USB Bluetooth Dongle, Ubuntu desktop will send Bluetooth advertisement, which will block CHIP from connecting via BLE. On Ubuntu server, you need to install <code>pi-bluetooth</code> via APT.</li>
<li>Ubuntu 20.04 or newer image for ARM64 platform.</li>
</ol>
</li>
<li><p class="startli">Building</p>
<p class="startli">Follow Building section of this document.</p>
</li>
<li>Running<ul>
<li>[Optional] Plug USB Bluetooth dongle<ul>
<li>Plug USB Bluetooth dongle and find its bluetooth controller selector as described in Linux BLE Settings.</li>
</ul>
</li>
<li><p class="startli">Run Linux Bridge Example App</p>
<p class="startli"><code>sh cd ~/connectedhomeip/examples/bridge-app/linux sudo out/debug/chip-bridge-app --ble-controller [bluetooth controller number] @section autotoc_md7 In this example, the device we want to use is hci1 sudo out/debug/chip-bridge-app --ble-controller 1 </code></p>
</li>
<li>Test the device using ChipDeviceController on your laptop / workstation etc. </li>
</ul>
</li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
構築:&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
