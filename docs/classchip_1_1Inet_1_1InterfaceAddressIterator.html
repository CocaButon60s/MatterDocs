<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MatterDocs: chip::Inet::InterfaceAddressIterator クラス</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MatterDocs
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 構築: Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','検索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">読み取り中…</div>
<div class="SRStatus" id="Searching">検索中…</div>
<div class="SRStatus" id="NoMatches">一致する文字列を見つけられません</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacechip.html">chip</a></li><li class="navelem"><a class="el" href="namespacechip_1_1Inet.html">Inet</a></li><li class="navelem"><a class="el" href="classchip_1_1Inet_1_1InterfaceAddressIterator.html">InterfaceAddressIterator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">公開メンバ関数</a> &#124;
<a href="classchip_1_1Inet_1_1InterfaceAddressIterator-members.html">全メンバ一覧</a>  </div>
  <div class="headertitle"><div class="title">chip::Inet::InterfaceAddressIterator クラス</div></div>
</div><!--header-->
<div class="contents">

<p>Iterator for the list of system network interface IP addresses.  
 <a href="classchip_1_1Inet_1_1InterfaceAddressIterator.html#details">[詳解]</a></p>

<p><code>#include &lt;<a class="el" href="InetInterface_8h_source.html">InetInterface.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
公開メンバ関数</h2></td></tr>
<tr class="memitem:a48bb38f9d716eae613a7c5905e301a3d" id="r_a48bb38f9d716eae613a7c5905e301a3d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1Inet_1_1InterfaceAddressIterator.html#a48bb38f9d716eae613a7c5905e301a3d">InterfaceAddressIterator</a> ()</td></tr>
<tr class="separator:a48bb38f9d716eae613a7c5905e301a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8308c8c13f71d6a8ca579f2f744b0955" id="r_a8308c8c13f71d6a8ca579f2f744b0955"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1Inet_1_1InterfaceAddressIterator.html#a8308c8c13f71d6a8ca579f2f744b0955">~InterfaceAddressIterator</a> ()</td></tr>
<tr class="separator:a8308c8c13f71d6a8ca579f2f744b0955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0abbabab4244a15191a0f7396af38b56" id="r_a0abbabab4244a15191a0f7396af38b56"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1Inet_1_1InterfaceAddressIterator.html#a0abbabab4244a15191a0f7396af38b56">HasCurrent</a> ()</td></tr>
<tr class="separator:a0abbabab4244a15191a0f7396af38b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d5c639eb655249e62aae3fe43887a6" id="r_a56d5c639eb655249e62aae3fe43887a6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1Inet_1_1InterfaceAddressIterator.html#a56d5c639eb655249e62aae3fe43887a6">Next</a> ()</td></tr>
<tr class="memdesc:a56d5c639eb655249e62aae3fe43887a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance the iterator to the next interface address.  <br /></td></tr>
<tr class="separator:a56d5c639eb655249e62aae3fe43887a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1970fa0952cf4484f93b4efeda9eeb" id="r_a4f1970fa0952cf4484f93b4efeda9eeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CHIPError_8h.html#a14096ae3b9aa35fdb19b9d949b212e0d">CHIP_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1Inet_1_1InterfaceAddressIterator.html#a4f1970fa0952cf4484f93b4efeda9eeb">GetAddress</a> (IPAddress &amp;outIPAddress)</td></tr>
<tr class="memdesc:a4f1970fa0952cf4484f93b4efeda9eeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current interface address.  <br /></td></tr>
<tr class="separator:a4f1970fa0952cf4484f93b4efeda9eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aaeb92c5fdae4aa35ef1767da16c280" id="r_a7aaeb92c5fdae4aa35ef1767da16c280"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1Inet_1_1InterfaceAddressIterator.html#a7aaeb92c5fdae4aa35ef1767da16c280">GetPrefixLength</a> ()</td></tr>
<tr class="memdesc:a7aaeb92c5fdae4aa35ef1767da16c280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the network prefix associated with the current interface address.  <br /></td></tr>
<tr class="separator:a7aaeb92c5fdae4aa35ef1767da16c280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a1f8a18becec984e4a6f0776297c27" id="r_ad8a1f8a18becec984e4a6f0776297c27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classchip_1_1Inet_1_1InterfaceId.html">InterfaceId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1Inet_1_1InterfaceAddressIterator.html#ad8a1f8a18becec984e4a6f0776297c27">GetInterfaceId</a> ()</td></tr>
<tr class="memdesc:ad8a1f8a18becec984e4a6f0776297c27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the network interface id associated with the current interface address.  <br /></td></tr>
<tr class="separator:ad8a1f8a18becec984e4a6f0776297c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305ee8ee017aa1dcb56e755da3b4707f" id="r_a305ee8ee017aa1dcb56e755da3b4707f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CHIPError_8h.html#a14096ae3b9aa35fdb19b9d949b212e0d">CHIP_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1Inet_1_1InterfaceAddressIterator.html#a305ee8ee017aa1dcb56e755da3b4707f">GetInterfaceName</a> (char *nameBuf, size_t nameBufSize)</td></tr>
<tr class="memdesc:a305ee8ee017aa1dcb56e755da3b4707f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the network interface associated with the current interface address.  <br /></td></tr>
<tr class="separator:a305ee8ee017aa1dcb56e755da3b4707f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af132a36994affd54b64b4d5b9776405d" id="r_af132a36994affd54b64b4d5b9776405d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1Inet_1_1InterfaceAddressIterator.html#af132a36994affd54b64b4d5b9776405d">IsUp</a> ()</td></tr>
<tr class="separator:af132a36994affd54b64b4d5b9776405d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2844bc9714618e583955555718c152fd" id="r_a2844bc9714618e583955555718c152fd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1Inet_1_1InterfaceAddressIterator.html#a2844bc9714618e583955555718c152fd">IsLoopback</a> ()</td></tr>
<tr class="separator:a2844bc9714618e583955555718c152fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a76f9538ccc768a6d85ceb3b08f8f5c" id="r_a4a76f9538ccc768a6d85ceb3b08f8f5c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1Inet_1_1InterfaceAddressIterator.html#a4a76f9538ccc768a6d85ceb3b08f8f5c">SupportsMulticast</a> ()</td></tr>
<tr class="separator:a4a76f9538ccc768a6d85ceb3b08f8f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa47c1ffa7d1f6457a0305475f8361dae" id="r_aa47c1ffa7d1f6457a0305475f8361dae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchip_1_1Inet_1_1InterfaceAddressIterator.html#aa47c1ffa7d1f6457a0305475f8361dae">HasBroadcastAddress</a> ()</td></tr>
<tr class="separator:aa47c1ffa7d1f6457a0305475f8361dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">詳解</h2>
<div class="textblock"><p>Iterator for the list of system network interface IP addresses. </p>
<p>Use objects of this class to iterate the list of system network interface interface IP addresses.</p>
<p>Methods on an individual instance of this class are <em>not</em> thread-safe; however separate instances may be used simultaneously by multiple threads.</p>
<p>On multi-threaded LwIP systems, instances are thread-safe relative to other threads accessing the global LwIP state provided that: 1) other threads hold the LwIP core lock while mutating the list of netifs; and 2) netif object themselves are never destroyed.</p>
<p>On sockets-based systems, iteration is always stable in the face of changes to the underlying system's interfaces and/or addresses.</p>
<p>On LwIP systems, iteration is stable except in the case where the interface associated with the current address is removed, in which case iteration may end prematurely. </p>
</div><h2 class="groupheader">構築子と解体子</h2>
<a id="a48bb38f9d716eae613a7c5905e301a3d" name="a48bb38f9d716eae613a7c5905e301a3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48bb38f9d716eae613a7c5905e301a3d">&#9670;&#160;</a></span>InterfaceAddressIterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">chip::Inet::InterfaceAddressIterator::InterfaceAddressIterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs an <a class="el" href="classchip_1_1Inet_1_1InterfaceAddressIterator.html" title="Iterator for the list of system network interface IP addresses.">InterfaceAddressIterator</a> object.</p>
<p>Starts the iterator at the first network address. On some platforms, this constructor may allocate resources recycled by the destructor. </p>

</div>
</div>
<a id="a8308c8c13f71d6a8ca579f2f744b0955" name="a8308c8c13f71d6a8ca579f2f744b0955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8308c8c13f71d6a8ca579f2f744b0955">&#9670;&#160;</a></span>~InterfaceAddressIterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">chip::Inet::InterfaceAddressIterator::~InterfaceAddressIterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroys an <a class="el" href="classchip_1_1Inet_1_1InterfaceAddressIterator.html" title="Iterator for the list of system network interface IP addresses.">InterfaceAddressIterator</a> object.</p>
<p>Recycles any resources allocated by the constructor. </p>

</div>
</div>
<h2 class="groupheader">関数詳解</h2>
<a id="a4f1970fa0952cf4484f93b4efeda9eeb" name="a4f1970fa0952cf4484f93b4efeda9eeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f1970fa0952cf4484f93b4efeda9eeb">&#9670;&#160;</a></span>GetAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IPAddress chip::Inet::InterfaceAddressIterator::GetAddress </td>
          <td>(</td>
          <td class="paramtype">IPAddress &amp;&#160;</td>
          <td class="paramname"><em>outIPAddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current interface address. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outIPAddress</td><td>The current interface address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>CHIP_NO_ERROR if the result IPAddress is valid. </dd>
<dd>
CHIP_ERROR_SENTINEL if the iterator is positioned beyond the end of the address list. </dd>
<dd>
other error from lower-level code </dd></dl>

</div>
</div>
<a id="ad8a1f8a18becec984e4a6f0776297c27" name="ad8a1f8a18becec984e4a6f0776297c27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8a1f8a18becec984e4a6f0776297c27">&#9670;&#160;</a></span>GetInterfaceId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchip_1_1Inet_1_1InterfaceId.html">InterfaceId</a> chip::Inet::InterfaceAddressIterator::GetInterfaceId </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the network interface id associated with the current interface address. </p>
<dl class="section return"><dt>戻り値</dt><dd>the interface id or <code>InterfaceId()</code> if the iterator is positioned beyond the end of the address list. </dd></dl>

</div>
</div>
<a id="a305ee8ee017aa1dcb56e755da3b4707f" name="a305ee8ee017aa1dcb56e755da3b4707f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a305ee8ee017aa1dcb56e755da3b4707f">&#9670;&#160;</a></span>GetInterfaceName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CHIPError_8h.html#a14096ae3b9aa35fdb19b9d949b212e0d">CHIP_ERROR</a> chip::Inet::InterfaceAddressIterator::GetInterfaceName </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>nameBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nameBufSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of the network interface associated with the current interface address. </p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nameBuf</td><td>region of memory to write the interface name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nameBufSize</td><td>size of the region denoted by <code>nameBuf</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>戻り値</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CHIP_NO_ERROR</td><td>successful result, interface name written </td></tr>
    <tr><td class="paramname">CHIP_ERROR_BUFFER_TOO_SMALL</td><td>name is too large to be written in buffer </td></tr>
    <tr><td class="paramname">CHIP_ERROR_INCORRECT_STATE</td><td>the iterator is not currently positioned on an interface address </td></tr>
    <tr><td class="paramname">other</td><td>another system or platform error</td></tr>
  </table>
  </dd>
</dl>
<p>Writes the name of the network interface as <code>NUL</code> terminated text string at <code>nameBuf</code>. </p>

</div>
</div>
<a id="a7aaeb92c5fdae4aa35ef1767da16c280" name="a7aaeb92c5fdae4aa35ef1767da16c280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aaeb92c5fdae4aa35ef1767da16c280">&#9670;&#160;</a></span>GetPrefixLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t chip::Inet::InterfaceAddressIterator::GetPrefixLength </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the network prefix associated with the current interface address. </p>
<dl class="section return"><dt>戻り値</dt><dd>the network prefix (in bits) or 0 if the iterator is positioned beyond the end of the address list.</dd></dl>
<p>On LwIP, this method simply returns the hard-coded constant 64.</p>
<p>Note Well: the standard subnet prefix on all links other than PPP links is 64 bits. On PPP links and some non-broadcast multipoint access links, the convention is either 127 bits or 128 bits, but it might be something else. On most platforms, the system's interface address structure can represent arbitrary prefix lengths between 0 and 128. </p>

</div>
</div>
<a id="aa47c1ffa7d1f6457a0305475f8361dae" name="aa47c1ffa7d1f6457a0305475f8361dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa47c1ffa7d1f6457a0305475f8361dae">&#9670;&#160;</a></span>HasBroadcastAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool chip::Inet::InterfaceAddressIterator::HasBroadcastAddress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns whether the network interface associated with the current interface address has an IPv4 broadcast address.</p>
<dl class="section return"><dt>戻り値</dt><dd><code>true</code> if the interface has a broadcast address, <code>false</code> if not, or if the iterator is not positioned on an interface address. </dd></dl>

</div>
</div>
<a id="a0abbabab4244a15191a0f7396af38b56" name="a0abbabab4244a15191a0f7396af38b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0abbabab4244a15191a0f7396af38b56">&#9670;&#160;</a></span>HasCurrent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool chip::Inet::InterfaceAddressIterator::HasCurrent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test whether the iterator is positioned on an interface address</p>
<dl class="section return"><dt>戻り値</dt><dd><code>true</code> if the iterator is positioned on an interface address; <code>false</code> if positioned beyond the end of the address list. </dd></dl>

</div>
</div>
<a id="a2844bc9714618e583955555718c152fd" name="a2844bc9714618e583955555718c152fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2844bc9714618e583955555718c152fd">&#9670;&#160;</a></span>IsLoopback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool chip::Inet::InterfaceAddressIterator::IsLoopback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns whether the current network interface is a loopback interface</p>
<dl class="section return"><dt>戻り値</dt><dd><code>true</code> if current network interface is a loopback interface, <code>false</code> if not, or if the iterator is positioned beyond the end of the list. </dd></dl>

</div>
</div>
<a id="af132a36994affd54b64b4d5b9776405d" name="af132a36994affd54b64b4d5b9776405d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af132a36994affd54b64b4d5b9776405d">&#9670;&#160;</a></span>IsUp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool chip::Inet::InterfaceAddressIterator::IsUp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns whether the network interface associated with the current interface address is up.</p>
<dl class="section return"><dt>戻り値</dt><dd><code>true</code> if current network interface is up, <code>false</code> if not, or if the iterator is not positioned on an interface address. </dd></dl>

</div>
</div>
<a id="a56d5c639eb655249e62aae3fe43887a6" name="a56d5c639eb655249e62aae3fe43887a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56d5c639eb655249e62aae3fe43887a6">&#9670;&#160;</a></span>Next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool chip::Inet::InterfaceAddressIterator::Next </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advance the iterator to the next interface address. </p>
<dl class="section return"><dt>戻り値</dt><dd><code>false</code> if advanced beyond the end, else <code>true</code>.</dd></dl>
<p>Advances the iterator to the next interface address or to a position beyond the end of the address list.</p>
<p>On LwIP, this method is thread-safe provided that: 1) other threads hold the LwIP core lock while mutating the netif list; and 2) netif objects themselves are never destroyed. Additionally, iteration on LwIP systems will terminate early if the current interface is removed from the list. </p>

</div>
</div>
<a id="a4a76f9538ccc768a6d85ceb3b08f8f5c" name="a4a76f9538ccc768a6d85ceb3b08f8f5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a76f9538ccc768a6d85ceb3b08f8f5c">&#9670;&#160;</a></span>SupportsMulticast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool chip::Inet::InterfaceAddressIterator::SupportsMulticast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns whether the network interface associated with the current interface address supports multicast.</p>
<dl class="section return"><dt>戻り値</dt><dd><code>true</code> if multicast is supported, <code>false</code> if not, or if the iterator is not positioned on an interface address. </dd></dl>

</div>
</div>
<hr/>このクラス詳解は次のファイルから抽出されました:<ul>
<li>connectedhomeip/src/inet/<a class="el" href="InetInterface_8h_source.html">InetInterface.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
構築:&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
